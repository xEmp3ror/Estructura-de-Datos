/*** @file graph.hpp* @brief Práctica 4: Grafo.* @author Rafael Román de los Reeyes* @date Mayo de 2018*/#ifndef __GRAPH_HPP__#define __GRAPH_HPP__#include "vertex.hpp"#include "edge.hpp"#include <cstdio>#include <cstdlib>#include <fstream>#include <iostream>#include <cstdlib>#include <vector>#include <cmath>#include <algorithm>using std::istream;using std::ostream;/*** @brief Espacio de nombres para la asignatura Estructuras de Datos.*/namespace ed {    /// Clase Graph    class Graph {        private:        	//Vector de vértices.			std::vector<ed::Vertex> _vertexes;			//Vector de lados.			std::vector<ed::Edge> _edges;			//Matriz de adyacencia.			std::vector< std::vector<double> > _matrix;			//Vector que será usado en Alg. Kruskal.			std::vector<int> _kruskal;			/// Variable que indica si el grado es dirigido o no.			bool _directed;			/// Cursor de vértices.			uint _cursorV;			/// Cursor de lados.			uint _cursorE;			/// Número de vértices.			uint _nVertexes;			/// Número de lados.			uint _nEdges;			/// Capacidad.			uint _capacity;		public:			/** @name Constructores. */			/**			* @brief Constructor con valores por defecto.			* @param capacity Capacidad del grafo (uint).			* @param directed Tipo de grafo (bool).			* @sa setCapacity().			* @sa setVertexes().			* @sa setEdges().			* @sa setCursorV().			* @sa setCursorE().			* @sa setDirected().			*/			Graph(int dirigido = 0) {				_matrix.resize(0);				_vertexes.resize(0);				_edges.resize(0);				_kruskal.resize(0);				_directed = dirigido;				_cursorV = -1;				_cursorE = -1;				_nVertexes = 0;				_nEdges = 0;				_capacity = 0;			}			/** @name Observadores. */			/**			* @brief Devuelve si el grafo es dirigido o no. 			* @return true si el grado es dirigido, false en caso contrario.			*/			inline bool getDirected() const { return _directed; }			/**			* @brief Devuelve el valor del cursor de vértices.			* @return Valor del cursor de vértices.			*/			inline uint getCursorV() const { return _cursorV; }			/**			* @brief Devuelve el valor del cursor de lados. 			* @return Valor del cursor de lados.			*/			inline uint getCursorE() const { return _cursorE; }			/**			* @brief Devuelve el número de vértices del grafo.			* @return Número de vértices del grafo.			*/			inline uint getVertexes() const { return _nVertexes; }			/**			* @brief Devuelve el número de lados del grafo.			* @return Número de lados del grafo.			*/			inline uint getEdges() const { return _nEdges; }			/**			* @brief Devuelve la capacidad del grafo.			* @return Capacidad del grafo.			*/			inline uint getCapacity() const { return _capacity; }			/**			* @brief Devuelve el número de vértices del grafo.			* @return Número de vértices.			*/			inline uint nVertexes() const { return _vertexes.size(); }			/**@name Modificadores. */			/**			* @brief Establece si el grafo es dirigido o no.			* @param directed Si el grafo es dirigido o no.			*/			inline void setDirected(const bool &directed) { _directed = directed; }			/**			* @brief Establece el valor del cursor de vértices.			* @param cursorV Valor del cursor de vértices (uint).			*/			inline void setCursorV(const uint &cursorV) { _cursorV = cursorV; }			/**			* @brief Establece el valor del cursor de lados.			* @param cursorE Valor del cursor de lados (uint).			*/			inline void setCursorE(const uint &cursorE) { _cursorE = cursorE; }			/**			* @brief Establece el número de vértices del grafo.			* @param vertexes Número de vértices del grafo.			*/			inline void setVertexes(const uint &vertexes) { _nVertexes = vertexes; }			/**			* @brief Establece el número de lados del grafo.			* @brief edges Número de lados del grafo (uint).			*/			inline void setEdges(const uint &edges) { _nEdges = edges; }			/**			* @brief Establece la capacidad del grafo.			* @param capacity Capacidad del grafo (uint).			*/			inline void setCapacity(const uint &capacity) { _capacity = capacity; }			/**			* @brief Calcula el peso del lado pasando dos vértices adyacentes.			* @param u Primer vértice (Vertex).			* @param v Segundo Vértice (Vertex).			* @return Peso del lado.			*/			double ponderate(ed::Vertex u, ed::Vertex v) const;			/**			* @brief Comprueba si el grafo está vacío.			* @return true Si el grafo está vacío, false en caso contrario.			* @sa getVertexes()			* @sa getEdges()			*/			inline bool isEmpty() const { return this->getVertexes() == 0 && this->getEdges() == 0; }			/**			* @brief Comprueba si dos vértices son adyacentes.			* @return true Si los lados son adyacentes, false en caso contrario.			* @note No confundir con la función adyacent.			* @note Halecs Function.			*/			bool hasAdy(ed::Vertex u, ed::Vertex v) const;			/**			* @brief Comprueba si el cursor de los vértices está en una posición válida.			* @return true Si el cursor de los vértices está en una posición válida, false en caso contrario.			*/			inline bool hasCurV() const { return _cursorV < _nVertexes; }						/**			* @brief Comprueba si el cursor de los lados está en una posición válida.			* @return true Si el cursor de los lados está en una posición válida, false en caso contrario.			*/			inline bool hasCurE() const { return _cursorE < _nEdges; }						/**			* @brief Devuelve el vértice referenciado por el cursor de vértices.			* @return Vértice referenciado por el cursor de vértices.			*/			inline const ed::Vertex & curVertex() const { return _vertexes[_cursorV]; }			/**			* @brief Devuelve el lado referenciado por el cursor de lados.			* @return Lado referenciado por el cursor de lados.			*/			inline const ed::Edge & curEdge() const { return _edges[_cursorE]; }			/**			* @brief Añade un vértice al grafo.			* @param x Primera componente de la coordenada (int).			* @param y Segunda componente de la coordenada (int).			*/            void addVertex(double x, double y);            /**            * @brief Añade un vértice al grafo.            * @param v Objeto de tipo vértice.            * @note Función sobrecargada.            */            void addVertex(ed::Vertex v) {				v.setLabel(_vertexes.size() + 1);				_vertexes.push_back(v);				adjust();				for (int i = 0; i < nVertexes(); ++i) {					if(v.getLabel() != _vertexes[i].getLabel()) {						addEdge(v, _vertexes[i]);					}				}				_cursorV =(int) _vertexes.size() - 1 ;		}            /**            * @brief Añade vértice a partir de dato para grafo Auxiliar.            * @param x Primera componente de la coordenada (int).			* @param y Segunda componente de la coordenada (int).            */            void addVertexN(double x, double y);			/**			* @brief Añade un lado al grafo.			* @note Al añadir un lado, se actualiza el valor del peso en la matriz de adyacencias.			* @param v Primer vértice.			* @param u Segundo vértice.			*/			void addEdge(ed::Vertex v, ed::Vertex u);			/**			* @brief Comprueba si un vértice existe en el grafo.			* @param v Vértice a comprobar si existe en el grafo (string).			* @return true Si el vértice existe en el grafo, false en caso contrario.			*/			inline bool searchVertex(ed::Vertex v) const {				for (int i = 0; i < (int)_edges.size(); i++) {					if(_vertexes[i] == v ) {						return true;					}				 }				return false;			}			/**			* @brief Comprueba si un lado existe en el grafo.			* @param l Lado a comprobar si existe en el grafo (Edge).			* @true Si el lado existe en el grafo, false en caso contrario.			*/			inline bool searchEdge(ed::Edge e) const {				for (int i = 0; i < (int)_edges.size(); i++) {					if(_edges[i] == e ) {						return true;					}				 }				return false;			}			/**			* @brief Busca qué nodo está unido con el vértice pasado.			* @param v Vértice (int).			* @return Entero.			*/			inline int find(int v) {				if(v == _kruskal[v]) {					return v;				} else {					return find(_kruskal[v]);				}			}			/**			* @brief Une dos sub-árboles.			* @param x Primer vértice.			* @param y Segundo vértice.			*/			inline void Union(int x, int y) {				int a = find(x);				int b = find(y);				_kruskal[a] = b;			}			/**			* @brief Devuelve el laod al que apunta el cursor.			* @return Objeto lado.			*/			inline const ed::Edge & currEdge() const { return _edges[_cursorE]; }			/**			* @brief Devuelve el elemento (i, j) de la matriz de Adyacencias.			* @param i Primera componente de la coordenada (int).			* @param j Segunda componente de la coordenada (int).			* @return Elemento pedido de la matriz.			*/			inline const double & getElement(int i, int j) const { return _matrix[i][j]; }			/**			* @brief Devuelve el elemento pedido del vector de vértices.			* @param i Posición del vector pedida (int).			* @return Elemento pedido.			*/			inline const ed::Vertex & getVertex(int i) const { return _vertexes[i-1]; }			/**			* @brief Inicializa.			*/			inline void make() {				for(int i = 0; i<nVertexes()+1; i++) {					_kruskal.push_back(i);				}			}			/**			* @brief Calcula la longitud total de los lados del árbol.			* @note Halecs Function.			* @return Longitud del árbol (double).			*/			inline double treeLength() const {				double length = 0;				for (int i = 0; i < (int)_edges.size(); i++) {					length += _edges[i].getItem();				}				return length;			}			/**			* @brief Ajusta la matriz de adyacencias.			*/			void adjust();			/**			* @brief Borra todo.			*/			inline void clear() {				_vertexes.clear();				_edges.clear();				_matrix.clear();				_kruskal.clear();				_cursorV = -1;				_cursorE = -1;			}			/**			* @brief Borra un vértice del grafo, señalado por el cursor.			* @note Halces Function.			*/			void removeVertex();			/*			* @brief Borra un lado del grafo, señalado por el cursor.			*/			inline void removeEdge() {				_matrix[currEdge().getFirst().getLabel()-1][currEdge().getSecond().getLabel()-1] = std::numeric_limits<double>::infinity();				_matrix[currEdge().getSecond().getLabel()-1][currEdge().getFirst().getLabel()-1] = std::numeric_limits<double>::infinity();				_edges.erase(_edges.begin() + _cursorE);			}			/*			* @brief Busca el primer vértice que coincida con el pasado como argumento.			* @param x Primera componente de la coordenada (double).			* @param y Segunda componente de la coordenada (double).			*/			void findFirstV(double x, double y);			/*			* @brief Busca el siguiente vértice al cursor que coincida con el pasado como argumento.			* @param x Primera componente de la coordenada (double).			* @param y Segunda componente de la coordenada (double).			*/			void findNextV(double x, double y);			/*			* @brief Busca el primer lado que coincida con el pasado como argumento.			* @param v Primer vértice (Vertex).			* @param u Segundo vértice (Vertex).			*/			void findFirstE(ed::Vertex v, ed::Vertex u);			/*			* @brief Busca el siguiente lado al cursor que coincida con el pasado como argumento.			* @param v Primer vértice (Vertex).			* @param u Segundo vértice (Vertex).			*/			void findNextE(ed::Vertex v, ed::Vertex u);			/*			* @brief Mueve el cursor de vértices a la posición i-ésima.			* @note Esta función sirve de interfaz para setCursorV()			* @param i Posición i-ésima a la que desplacar el cursor (uint).			* @sa setCursorV()			*/			inline void goTo(const uint &i) { this->setCursorV(i); }						/**			* @brief Mueve el cursor de vértices al principio.			* @sa goTo()			*/			inline void firstVertex() { this->goTo(0); }			/**			* @brief Mueve el cursor de vértices a la siguiente posición.			* @sa setCursorV()			* @sa getCursorV()			*/			inline void nextVertex() { this->setCursorV(this->getCursorV()+1); }			/**			* @brief Mueve el cursor de lados al principio.			*/			inline void firstEdge() {				_cursorE = 0;				_cursorV = currEdge().getFirst().getLabel() -1;			}			/**			* @brief Comprueba que lado es mayor.			* @return true Si el mayor es el segundo lado, false si es el primero.			*/			inline static bool sortEdge(Edge a, Edge b) { return a.getItem() < b.getItem(); }			/* 			* @brief Coloca el cursor en la posicion pasada.			* @param v Vertice que buscar (Vertex).			*/			inline void goToVertex(ed::Vertex v) {				for (int i = 0; i < (int)_vertexes.size(); ++i) {					if(v.getLabel() == _vertexes[i].getLabel()) {						_cursorV = i;					}				}			}			/*			* @brief Coloca cursor en la posición correspondiente al lado pasado.			* @param v Primer vértice (Vertex).			* @param u Segundo vértice (Vertex).			*/			void goToEdge(ed::Vertex u, ed::Vertex v);			/*			* @brief Comprueba si dos nodos pertenecen al mismo sub-arbol. Sirve para evitar ciclos.			* @note Halecs Function. Esta función hace que sea más facil Kruskal.			* @return True si pertenece, false en caso contrario.			*/			inline bool same(int x, int y) {				if(find(x) == find(y)) {					return true;				}				return false;			}			/* 			* @brief Imprime la matriz de adyacencia.			*/			inline void printMatrix() {				int i, j;				for(i = 0; i < nVertexes(); i++) {					for( j = 0; j < nVertexes(); j++) {						std::cout<< _matrix[i][j]<<"\t";					}					std::cout<<std::endl;				}				}			/*			* @brief Ejecuta el Algoritmo de Prim.			* @return Objeto de clase grafo.			*/			ed::Graph algorithmPrim();			/*			* @brief Ejecuta el Algoritmo de Kruskal.			* @return Objeto de clase grafo.			*/			ed::Graph algorithmKruskal();			/** @name Operadores. */			/**			* @brief Operador de extracción.			* @param o Flujo de salida.			* @param g Grafo.			* @return Devuelve el stream de salida.			*/			friend std::ostream &operator<<(std::ostream &o, const Graph &g) {			int i,j;			for(i=0; i< g.nVertexes(); i++) {				for(j=0; j< g.nVertexes(); j++) {					o<<g.getElement(i,j)<<"\t";				}				o<<"\n";			}			return o;			}	};}#endif